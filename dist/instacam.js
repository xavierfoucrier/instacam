/*!
  instacam â€“ Instant canvas video
  Xavier Foucrier @xavierfoucrier 2019 MIT
  1.9.2
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Instacam", [], factory);
	else if(typeof exports === 'object')
		exports["Instacam"] = factory();
	else
		root["Instacam"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/instacam.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/defaults.js":
/*!*************************!*\
  !*** ./src/defaults.js ***!
  \*************************/
/*! exports provided: defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaults\", function() { return defaults; });\n\n\n// default properties\nlet defaults = {\n\n  // {Number} width of the viewport element\n  width: 400,\n\n  // {Number} height of the viewport element\n  height: 300,\n\n  // {Boolean} true|false, defines if the capture start automatically\n  autostart: true,\n\n  // {Boolean} true|false, defines if the camera video stream is enabled\n  camera: true,\n\n  // {String} front|back, defines which camera use to capture the video stream\n  mode: 'front',\n\n  // {Number} refresh rate in frames per second of the camera video stream\n  framerate: 30,\n\n  // {Number} ratio of the camera video stream\n  ratio: 4 / 3,\n\n  // {Boolean} true|false, defines if the camera audio stream is enabled\n  sound: false,\n\n  // {Number} [0..100] volume of the camera audio stream\n  volume: 100,\n\n  // {Boolean} true|false, mirror mode of the viewport (css transform)\n  mirror: false,\n\n  // {Number} [0..1] opacity of the viewport (css)\n  opacity: 1,\n\n  // {Number} [0..*] brightness of the viewport (css filter)\n  brightness: 1,\n\n  // {Number} [0..*] contrast of the viewport (css filter)\n  contrast: 1,\n\n  // {Number} [0..*] saturation of the viewport (css filter)\n  saturation: 1,\n\n  // {Number} [0..360] hue of the viewport (css filter)\n  hue: 0,\n\n  // {Number} [0..1] invert the color of the viewport (css filter)\n  invert: 0,\n\n  // {Number} [0..1] grayscale of the viewport (css filter)\n  grayscale: 0,\n\n  // {Number} [0..1] sepia of the viewport (css filter)\n  sepia: 0,\n\n  // {Number} [0..*] blur of the viewport (css filter)\n  blur: 0,\n\n  // {String} svg filtering of the viewport (css filter)\n  url: '',\n\n  // {Object} blend layer of the viewport (css mix blend mode)\n  blend: {},\n\n  // {Function} custom filter applied to the viewport\n  filter: null,\n\n  // {Function} callback used when the stream is fully captured\n  done: null,\n\n  // {Function} callback used when the stream capture fails\n  fail: null,\n\n  // {Function} callback used when a browser doesn't support the requirements\n  unsupported: null\n};\n\n\n//# sourceURL=webpack://Instacam/./src/defaults.js?");

/***/ }),

/***/ "./src/instacam.js":
/*!*************************!*\
  !*** ./src/instacam.js ***!
  \*************************/
/*! exports provided: Instacam */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Instacam\", function() { return Instacam; });\n/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults.js */ \"./src/defaults.js\");\n/* harmony import */ var _support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./support.js */ \"./src/support.js\");\n\n\n\n\n\nclass Instacam {\n\n  /**\n    Class constructor\n    @param {Object} viewport - selector or canvas element from the DOM\n    @param {Object} properties - custom properties of the class\n  */\n  constructor(viewport, properties) {\n\n    // assign custom user properties to defaults\n    this._props = Object.assign({}, _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"], properties);\n\n    // check for browser support\n    if (!_support_js__WEBPACK_IMPORTED_MODULE_1__[\"requirement\"]) {\n      if (typeof this._props.unsupported === 'function') {\n        this._props.unsupported();\n      }\n\n      return;\n    }\n\n    // rewrite the viewport element if the user passed a selector to the constructor\n    if (typeof viewport === 'string') {\n      viewport = document.querySelector(viewport);\n    }\n\n    // check the viewport element\n    if (typeof viewport === 'undefined' || viewport === null || viewport.nodeName.toLowerCase() !== 'canvas') {\n      throw new Error('Invalid viewport, you need to pass a valid selector or HTML5 canvas element');\n    }\n\n    // initialize the viewport\n    this.viewport = viewport;\n    this.viewport.width = this._props.width;\n    this.viewport.height = this._props.height;\n\n    // create the media element\n    this._media = document.createElement('video');\n\n    // set some media element properties\n    this._media.style.display = 'none';\n    this._media.autoplay = true;\n    this._media.width = this._props.width;\n    this._media.height = this._props.height;\n\n    // attach the media element to the DOM\n    this.viewport.parentNode.insertBefore(this._media, this.viewport.nextSibling);\n\n    // create the container\n    this._container = document.createElement('div');\n    this._container.setAttribute('data-instacam', '');\n\n    // attach the container element to the DOM\n    this.viewport.parentNode.insertBefore(this._container, this.viewport);\n\n    // attach the viewport and media elements to the container\n    this._container.appendChild(this.viewport);\n    this._container.appendChild(this._media);\n\n    // apply the css mirror mode on the viewport\n    this.mirror = this._props.mirror;\n\n    // autostart the stream capture depending on the properties\n    if (this._props.autostart === true) {\n\n      // compute the css filter properties\n      this._compute();\n\n      // capture the device stream\n      this._capture();\n    }\n  }\n\n  /**\n    Capture the media stream to the viewport through getUserMedia API\n  */\n  _capture() {\n\n    // prevent from streaming errors\n    try {\n\n      // capture the media stream\n      navigator.mediaDevices.getUserMedia({\n        audio: this._props.sound,\n        video: (() => {\n          if (this._props.camera === false) {\n            return false;\n          }\n\n          return {\n            frameRate: this._props.framerate,\n            aspectRatio: this._props.ratio,\n            facingMode: this._props.mode === 'front' ? 'user' : 'environment'\n          };\n        })()\n      }).then((stream) => {\n\n        // store the blob stream\n        this._stream = stream;\n\n        // capture the blob stream\n        this._media.srcObject = stream;\n\n        // set the volume at start\n        this.volume = this._props.volume;\n\n        // animation loop used to properly render the viewport\n        const loop = () => {\n\n          // render the viewport with or without custom filter\n          if (typeof this._props.filter !== 'function') {\n            this.viewport.getContext('2d').drawImage(this._media, 0, 0, this._props.width, this._props.height);\n          } else {\n\n            // use a buffer when applying a custom filter to prevent the viewport from blinking or flashing\n            if (typeof this._buffer === 'undefined') {\n              this._buffer = document.createElement('canvas');\n              this._buffer.style.display = 'none';\n              this._buffer.width = this._props.width;\n              this._buffer.height = this._props.height;\n              this.viewport.parentNode.insertBefore(this._buffer, this.viewport.nextSibling);\n            }\n\n            this._buffer.getContext('2d').drawImage(this._media, 0, 0, this._props.width, this._props.height);\n            this.viewport.getContext('2d').putImageData(this._filter(this._buffer.getContext('2d').getImageData(0, 0, this._props.width, this._props.height)), 0, 0);\n          }\n\n          // make this function run at 60fps\n          requestAnimationFrame(loop);\n        };\n\n        // render the first frame\n        requestAnimationFrame(loop);\n\n        if (typeof this._props.done === 'function') {\n          this._props.done();\n        }\n      }).catch((exception) => {\n        if (typeof this._props.fail === 'function') {\n          this._props.fail(exception);\n        }\n      });\n    } catch(exception) {\n      if (typeof this._props.fail === 'function') {\n        this._props.fail(exception);\n      }\n    }\n  }\n\n  /**\n    Compute and apply the css filter effects to the viewport\n  */\n  _compute() {\n\n    // build the css layer depending on the properties\n    this._style = this._props.opacity !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].opacity ? `opacity(${this._props.opacity}) ` : '';\n    this._style += this._props.brightness !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].brightness ? `brightness(${this._props.brightness}) ` : '';\n    this._style += this._props.contrast !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].contrast ? `contrast(${this._props.contrast}) ` : '';\n    this._style += this._props.saturation !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].saturation ? `saturate(${this._props.saturation}) ` : '';\n    this._style += this._props.hue !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].hue ? `hue-rotate(${this._props.hue}deg) ` : '';\n    this._style += this._props.invert !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].invert ? `invert(${this._props.invert}) ` : '';\n    this._style += this._props.grayscale !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].grayscale ? `grayscale(${this._props.grayscale}) ` : '';\n    this._style += this._props.sepia !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].sepia ? `sepia(${this._props.sepia}) ` : '';\n    this._style += this._props.blur !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].blur ? `blur(${this._props.blur}px) ` : '';\n    this._style += this._props.url !== _defaults_js__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"].url ? `url(${this._props.url}) ` : '';\n\n    // apply the css filter effects to the viewport\n    this.viewport.style.filter = this._style;\n\n    // build the blend layer depending on the properties\n    if (Object.keys(this._props.blend).length !== 0) {\n\n      // create the blending element\n      if (typeof this._blend === 'undefined') {\n        this._blend = document.createElement('div');\n\n        // prepend the blending element to the viewport\n        this.viewport.parentNode.insertBefore(this._blend, this.viewport);\n      }\n\n      // get the viewport bounds\n      const bounds = this.viewport.getBoundingClientRect();\n\n      // set the blending styles\n      this._blend.style = `position:absolute;z-index:1;width:${bounds.width}px;height:${bounds.height}px;mix-blend-mode:${this._props.blend.mode};background:${this._props.blend.color};pointer-events:none;`;\n    } else if (typeof this._blend !== 'undefined') {\n\n      // remove the blend layer from the DOM if there is no blending applied\n      this._blend.parentNode.removeChild(this._blend);\n      delete this._blend;\n    }\n  }\n\n  /**\n    Apply a custom filter to the viewport\n    @param {Object} image - image object from the canvas element\n    @return {Object} image data object containing pixels informations\n  */\n  _filter(image) {\n\n    // get the image data\n    let data = image.data;\n\n    // prevent from filtering errors\n    try {\n\n      // loop through all pixels and apply the filter\n      for (let y = 0; y < this._props.height; y++) {\n        for (let x = 0; x < this._props.width; x++) {\n\n          // detect the pixel offset\n          const offset = ((this._props.width * y) + x) * 4;\n\n          // call the filter\n          const filter = this._props.filter({\n            'offset': offset,\n            'x': x,\n            'y': y,\n            'red': data[offset],\n            'green': data[offset + 1],\n            'blue': data[offset + 2],\n            'alpha': data[offset + 3]\n          });\n\n          // apply the filter\n          data[offset] = filter[0];\n          data[offset + 1] = filter[1];\n          data[offset + 2] = filter[2];\n          data[offset + 3] = filter[3];\n        }\n      }\n\n      return image;\n    } catch(exception) {\n      throw new Error('Invalid filter, you need to return a valid [red, green, blue, alpha] pixel array');\n    }\n  }\n\n  /**\n    Start the stream capture\n  */\n  start() {\n\n    // compute the css filter properties\n    this._compute();\n\n    // capture the device stream\n    this._capture();\n  }\n\n  /**\n    Stop the stream capture\n  */\n  stop() {\n\n    // exit if no stream is active\n    if (typeof this._stream === 'undefined') {\n      return;\n    }\n\n    // loop through all stream tracks (audio + video) and stop them\n    this._stream.getTracks().forEach(function(track) {\n      track.stop();\n    });\n\n    // reset the media element\n    this._media.srcObject = null;\n  }\n\n  /**\n    Snap and crop the viewport to return image data\n    @param {Number} left - left position of the snapping area\n    @param {Number} top - top position of the snapping area\n    @param {Number} width - width of the snapping area\n    @param {Number} height - height of the snapping area\n    @return {Object} image data object containing pixels informations\n  */\n  snap(left = 0, top = 0, width = this._props.width, height = this._props.height) {\n\n    // check the snap size area\n    if (width <= 0 || height <= 0) {\n      throw new Error('Invalid snap area, you need to specify a positive width and height for your image capture');\n    }\n\n    return this.viewport.getContext('2d').getImageData(left, top, width, height);\n  }\n\n  /**\n    Save the viewport to a specific image file format\n    @param {String} format - png|jpeg|webp image file format\n    @param {Number} quality - [0..1] image quality\n    @return {String} UTF-16 data image URI (DOMString)\n  */\n  save(format = 'png', quality = 1) {\n    return this.viewport.toDataURL('image/' + format, quality);\n  }\n\n  /**\n    Mute the microphone\n  */\n  mute() {\n    this._props.muted = this._media.muted = true;\n  }\n\n  /**\n    Unmute the microphone\n  */\n  unmute() {\n    this._props.muted = this._media.muted = false;\n  }\n\n  /**\n    Get the camera facing mode\n    @return {String} front|back facing mode of the camera\n  */\n  get mode() {\n    return this._props.mode;\n  }\n\n  /**\n    Set the camera facing mode\n    @param {String} mode - front|back facing mode of the camera\n  */\n  set mode(mode) {\n    if (typeof mode !== 'string' || (mode !== 'front' && mode !== 'back')) {\n      throw new Error('Invalid facing mode, you need to give a valid string front|back');\n    }\n\n    this._props.mode = mode;\n\n    // stop all video tracks\n    this._stream.getVideoTracks().forEach(function(track) {\n      track.stop();\n    });\n\n    // restart the capture\n    this._capture();\n  }\n\n  /**\n    Get the microphone mute state\n    @return {Boolean} true|false microphone mute state\n  */\n  get muted() {\n    return this._media.muted;\n  }\n\n  /**\n    Get the camera volume\n    @return {Number} [0..100] volume of the camera audio stream\n  */\n  get volume() {\n    return this._props.volume;\n  }\n\n  /**\n    Set the camera volume\n    @param {Number} volume - [0..100] volume of the camera audio stream\n  */\n  set volume(volume) {\n    if (typeof volume !== 'number' || volume < 0 || volume > 100) {\n      throw new Error('Invalid volume, you need to give a number between 0 and 100');\n    }\n\n    this._media.volume = this._props.volume = volume / 100;\n  }\n\n  /**\n    Get the camera mirror mode\n    @return {Boolean} true|false, mirror mode of the viewport (css transform)\n  */\n  get mirror() {\n    return this._props.mirror;\n  }\n\n  /**\n    Set the camera mirror mode\n    @param {Boolean} mirror - true|false, mirror mode of the viewport (css transform)\n  */\n  set mirror(mirror) {\n    if (typeof mirror !== 'boolean') {\n      throw new Error('Invalid mirror mode, you need to give a boolean to enable or disable the mirror mode');\n    }\n\n    let transform = getComputedStyle(this.viewport).getPropertyValue('transform');\n    transform = transform !== 'none' ? transform : '';\n\n    this.viewport.style.transform = mirror === true ? `${transform} scale(-1, 1)` : '';\n    this._props.mirror = mirror;\n  }\n\n  /**\n    Get the viewport opacity\n    @return {Number} [0..1] opacity of the viewport (css)\n  */\n  get opacity() {\n    return this._props.opacity;\n  }\n\n  /**\n    Set the viewport opacity\n    @param {Number} opacity - [0..1] opacity of the viewport (css)\n  */\n  set opacity(opacity) {\n    if (typeof opacity !== 'number' || opacity < 0 || opacity > 1) {\n      throw new Error('Invalid opacity, you need to give a number between 0 and 1');\n    }\n\n    this._props.opacity = opacity;\n    this._compute();\n  }\n\n  /**\n    Get the viewport brightness\n    @return {Number} [0..*] brightness of the viewport (css filter)\n  */\n  get brightness() {\n    return this._props.brightness;\n  }\n\n  /**\n    Set the viewport brightness\n    @param {Number} brightness - [0..*] brightness of the viewport (css filter)\n  */\n  set brightness(brightness) {\n    if (typeof brightness !== 'number' || brightness < 0) {\n      throw new Error('Invalid brightness, you need to give a number above 0');\n    }\n\n    this._props.brightness = brightness;\n    this._compute();\n  }\n\n  /**\n    Get the viewport contrast\n    @return {Number} [0..*] contrast of the viewport (css filter)\n  */\n  get contrast() {\n    return this._props.contrast;\n  }\n\n  /**\n    Set the viewport contrast\n    @param {Number} contrast - [0..*] contrast of the viewport (css filter)\n  */\n  set contrast(contrast) {\n    if (typeof contrast !== 'number' || contrast < 0) {\n      throw new Error('Invalid contrast, you need to give a number above 0');\n    }\n\n    this._props.contrast = contrast;\n    this._compute();\n  }\n\n  /**\n    Get the viewport saturation\n    @return {Number} [0..*] saturation of the viewport (css filter)\n  */\n  get saturation() {\n    return this._props.saturation;\n  }\n\n  /**\n    Set the viewport saturation\n    @param {Number} saturation - [0..*] saturation of the viewport (css filter)\n  */\n  set saturation(saturation) {\n    if (typeof saturation !== 'number' || saturation < 0) {\n      throw new Error('Invalid saturation, you need to give a number above 0');\n    }\n\n    this._props.saturation = saturation;\n    this._compute();\n  }\n\n  /**\n    Get the viewport hue\n    @return {Number} [0..360] hue of the viewport (css filter)\n  */\n  get hue() {\n    return this._props.hue;\n  }\n\n  /**\n    Set the viewport hue\n    @param {Number} hue - [0..360] hue of the viewport (css filter)\n  */\n  set hue(hue) {\n    if (typeof hue !== 'number' || hue < 0 || hue > 360) {\n      throw new Error('Invalid hue, you need to give a number between 0 and 360');\n    }\n\n    this._props.hue = hue;\n    this._compute();\n  }\n\n  /**\n    Get the viewport color inversion\n    @return {Number} [0..1] invert the color of the viewport (css filter)\n  */\n  get invert() {\n    return this._props.invert;\n  }\n\n  /**\n    Set the viewport color inversion\n    @param {Number} invert - [0..1] invert the color of the viewport (css filter)\n  */\n  set invert(invert) {\n    if (typeof invert !== 'number' || invert < 0 || invert > 1) {\n      throw new Error('Invalid invert, you need to give a number between 0 and 1');\n    }\n\n    this._props.invert = invert;\n    this._compute();\n  }\n\n  /**\n    Get the viewport grayscale\n    @return {Number} [0..1] grayscale of the viewport (css filter)\n  */\n  get grayscale() {\n    return this._props.grayscale;\n  }\n\n  /**\n    Set the viewport grayscale\n    @param {Number} grayscale - [0..1] grayscale of the viewport (css filter)\n  */\n  set grayscale(grayscale) {\n    if (typeof grayscale !== 'number' || grayscale < 0 || grayscale > 1) {\n      throw new Error('Invalid grayscale, you need to give a number between 0 and 1');\n    }\n\n    this._props.grayscale = grayscale;\n    this._compute();\n  }\n\n  /**\n    Get the viewport sepia\n    @return {Number} [0..1] sepia of the viewport (css filter)\n  */\n  get sepia() {\n    return this._props.sepia;\n  }\n\n  /**\n    Set the viewport sepia\n    @param {Number} sepia - [0..1] sepia of the viewport (css filter)\n  */\n  set sepia(sepia) {\n    if (typeof sepia !== 'number' || sepia < 0 || sepia > 1) {\n      throw new Error('Invalid sepia, you need to give a number between 0 and 1');\n    }\n\n    this._props.sepia = sepia;\n    this._compute();\n  }\n\n  /**\n    Get the viewport blur\n    @return {Number} [0..*] blur of the viewport (css filter)\n  */\n  get blur() {\n    return this._props.blur;\n  }\n\n  /**\n    Set the viewport blur\n    @param {Number} blur - [0..*] blur of the viewport (css filter)\n  */\n  set blur(blur) {\n    if (typeof blur !== 'number' || blur < 0) {\n      throw new Error('Invalid blur, you need to give a number above 0');\n    }\n\n    this._props.blur = blur;\n    this._compute();\n  }\n\n  /**\n    Get the viewport svg filtering\n    @return {String} svg filtering of the viewport (css filter)\n  */\n  get url() {\n    return this._props.url;\n  }\n\n  /**\n    Set the viewport svg filtering\n    @param {String} url - svg filtering of the viewport (css filter)\n  */\n  set url(url) {\n    if (typeof url !== 'string') {\n      throw new Error('Invalid url, you need to give a string');\n    }\n\n    this._props.url = url;\n    this._compute();\n  }\n\n  /**\n    Get the viewport blend layer\n    @return {Object} blend layer of the viewport (css mix blend mode)\n  */\n  get blend() {\n    return this._props.blend;\n  }\n\n  /**\n    Set the viewport blend layer\n    @param {Object} blend - blend layer of the viewport (css mix blend mode)\n  */\n  set blend(blend) {\n    if (typeof blend !== 'object') {\n      throw new Error('Invalid blend, you need to give a valid object with {mode|color} or an empty object to disable blending');\n    }\n\n    this._props.blend = blend;\n    this._compute();\n  }\n\n  /**\n    Get the custom filter\n    @return {Function} custom filter of the viewport\n  */\n  get filter() {\n    return this._props.filter;\n  }\n\n  /**\n    Set the custom filter\n    @param {Function} filter - custom filter applied to the viewport\n  */\n  set filter(filter) {\n    if (filter !== null && typeof filter !== 'function') {\n      throw new Error('Invalid filter, you need to give a function or null to disable the custom filtering');\n    }\n\n    this._props.filter = filter;\n  }\n\n  /**\n    Get style applied to the viewport\n    @return {Array} style applied to the viewport (css)\n  */\n  get style() {\n    return this._style.length !== 0 ? this._style.trim().split(' ') : [];\n  }\n\n  /**\n    Get the current camera audio/video hardware data\n    @return {Object} hardware informations from the current audio/video tracks\n  */\n  get hardware() {\n\n    // return null if no stream is active\n    if (typeof this._stream === 'undefined') {\n      return null;\n    }\n\n    // get the current audio and video tracks\n    let audio = this._stream.getAudioTracks().filter(track => track.readyState === 'live')[0];\n    let video = this._stream.getVideoTracks().filter(track => track.readyState === 'live')[0];\n\n    // create the hardware object\n    return {\n      audio: typeof audio === 'undefined' ? null : {\n        id: audio.id,\n        name: audio.label\n      },\n      video: typeof video === 'undefined' ? null : {\n        id: video.id,\n        name: video.label\n      }\n    };\n  }\n}\n\n\n//# sourceURL=webpack://Instacam/./src/instacam.js?");

/***/ }),

/***/ "./src/support.js":
/*!************************!*\
  !*** ./src/support.js ***!
  \************************/
/*! exports provided: requirement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requirement\", function() { return requirement; });\n\n\n// browser requirement needed for Instacam to properly work\nlet requirement = 'requestAnimationFrame' in window && 'mediaDevices' in navigator && 'Promise' in window;\n\n\n//# sourceURL=webpack://Instacam/./src/support.js?");

/***/ })

/******/ });
});